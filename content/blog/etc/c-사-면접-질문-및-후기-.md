---
title: C 사 면접 질문 및 후기
date: 2020-06-17 17:06:64
category: etc
draft: false
---

나름 공부도 하고 준비해서 면접에 갔으나, 너무 긴장된 나머지 단어도.. 그 어떤것도 기억이 하나도 나지않았다..

우선 기억나는 질문들을 정리해보았다.

### 면접 질문

1. 쿠키와 섹션의 차이

   - 공통점: 웹 통신간 유지하려는 정보(ex. 로그인 정보등)를 저장하기 위해 사용하는것
   - 차이점: 저장위치, 저장형식, 용량제한, 만료시점 등
     - 쿠키: 개인 PC 저장됨.
     - 세션: 접속중인 웹 서버에 저장됨.

2. useEffect와 useState는 무엇인가

   - useEffect : useEffect 는 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook 이다. 만약 useEffect 에서 설정한 함수가 컴포넌트가 화면에 가장 처음 렌더링 될 때만 실행되고 **업데이트 할 경우에는 실행 할 필요가 없는 경우엔 함수의 두 번째 파라미터로 비어있는 배열**을 넣어주시면 됩니다.

   - useState : useState는 함수에 state를 제공합니다. initialState를 파라미터로 받고, state와 state를 변경할 setState 함수를 반환합니다.
     useState가 반환하는 첫 번째 인자인 state와 두번째 인자인 setState를 **비구조화 할당 문법**을 통해 count, setCount로 받아서 사용할 수 있게 됩니다. **setCount로 count state를 변경하면 렌더링이 다시 일어납니다.**

3. 리액트에서 상태관리를 한적이 있는지

   - 리액트의 상태관리 ? : context API, Mobx, redux

4. 라이브러리랑 프레임워크의 차이
   어플리케이션의 Flow(흐름)를 누가 쥐고 있느냐에 달려 있습니다.
   프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜 넣으며 반면에 라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져가 쓰는 것이라고 할 수 있습니다.
   **다시 말해, 라이브러리는 라이브러리를 가져다가 사용하고 호출하는 측에 전적으로 주도성이 있으며 프레임 워크는 그 틀안에 이미 제어 흐름에 대한 주도성이 내재하고 있습니다.** - **라이브러리**: 내코드에서 라이브러리를 호출한다. - **프레임워크**: 프레임워크는 나의 코드를 호출한다.

5. 노드가 무엇인지

   - 요소노드: 태그나 element라고 하는 것들이다. `<body><head></head></body>` **요소 노드들 끼리는 서로 포함 관계를 많이 갖게 되는데 다른 요소에 포함되지 않는 유일한 요소노드는 <HTML>이 된다.**

   - 텍스트노드: 웹 문서에는 내용이 들어 있고 대부분의 내용은 텍스트로 제공 할 수 있다.
     `<p>이 문장이 텍스트노드이다.</p>` 단, XHTML에서 이 텍스트 노드가 된다.

   - 속성노드: 요소노드의 태그안에 있다. `<p title></p>` title이 속성노드이다.

6. npm이 무엇인지
   node.js로 만들어진 pakage(module)을 관리해주는 툴이다.
   즉, npm은 Node.js로 만들어진 모듈을 웹에서 받아서 설치하고 관리해주는 프로그램이다.

7) 리팩토링이 무엇인지

   - 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법
   - 코드가 작성된 후에 디자인을 개선하는 작업
   - 모든 것을 미리 생각하기 보다는 개발을 하면서 지속적으로 좋은 디자인을 찾는다.
   - 메소드 내의 지역변수와 parameter를 주의 깊게 볼 필요가 있다.
   - 값이 수정되지 않는 변수는 파라미터로 넘길 수 있다.
   - 값이 수정되는 변수는 주의가 필요하다. 변화되는 부분을 함수로 추출하여 리턴 값으로 돌려줄 수 있다.

8) 클린코딩이 무엇인지
   **읽기 쉬운 코드가 클린코드이다.**
   - 클린코드 하는법
     1. Coding 표준, 아키텍쳐 표준 및 설계 가이드를 준수하라.
     2. 단순한 것이 효율적이며, 복잡함을 최소화하라
     3. 참조되거나 수정되는 코드는 원래보다 clean하게 해야 함.
     4. 항상 근복적인 원인을 찾아라. 그렇지 않으면 반복될 것이다.
     5. 하나의 파일은 하나의 언어로 작성하라. (Java, JavaScript, Html)
   * 설계 관점으로 클린코드를 이야기할 때 가장 많이 회자되는 것이 위의 **SOLID** 원칙이다
     1. s / 하나의 클래스는 하나의 책임만 가져야한다.
     2. o / 클래스는 확장에 대하여 열려있어야하고, 변경에 대해서는 닫혀있어야한다.
     3. L / 파생 클래스의 메소드는 기반 클래스의 매서드를 대처하여 사용될 수 있어야한다.
     4. I / 클라이언트가 사용하지않는 메소드에 의존하지 않아야한다.
     5. D / 추상회된 것은 구체적인것에 의존하면 안된다. (자주 변경되는 구체적인 것에 의존하지 말고 추상화된 것을 참조)

9. 웹팩이 무엇인지
   웹팩은 기본적으로 모듈 번들러다.
   의존성 그래프에서 엔트리로 그래프의 시작점을 설정하면 웹팩은 모든 자원을 모듈로 로딩한 후 아웃풋으로 묶어준다. 로더로 각 모듈별로 바벨, 사스변환 등의 처리하고 이 결과를 플러그인이 받아 난독화, 텍스트 추출등의 추가 작업을 한다.

10. 디자인 패턴 사용해본적 있는지
    디자인패턴이란, 소프트웨어를 디자인할때 function class를 작성하는 여러가지 패턴이 있다.
    리액트에서는 대표적으로 **Container+Presenter** 등이 있다.
11. Container+Presenter

    - **Container 컴포넌트는 논리 담당, logic과 api를 갖고 있고, Presenter 컴포넌트는 UI 담당, 사진 등을 갖고있다.** - 폴더 구조 + Routes/Home/index.js + Routes/Home/HomePresenter.js + Routes/Home/HomeContainer.js - 각 파일별 역할 + index.js (홈 라웉의 인덱스 파일은 홈컴테이너를 호출)
      `javascript import HomeContainer from "./HomeContainer"; export default HomeContainer;` + HomePresenter.js (홈 컨테이너는 홈프리젠터를 렌더링)

      ```javascript
      import React from 'react'
      import HomePresenter from './HomePresenter'

      export default class extends React.Component {
        state = {
          nowPlaying: null,
          upComing: null,
          popular: null,
          error: null,
          loading: null,
        }

        render() {
          const { nowPlaying, upComing, popular, error, loading } = this.state
          return (
            <HomePresenter
              nowPlaying={nowPlaying}
              upComing={upComing}
              popular={popular}
              error={error}
              loading={loading}
            />
          )
        }
      }
      ```

      - HomePresenter.js (보이는 화면)
        ```javascript
        export default () => 'Home'
        ```

11) 리액트와 일반 코딩의 차이점

- 리액트는 Virture Dom 즉, 가상돔이다. 일반적으로 html 코드를 짜고 웹 브라우저에서 html 파일을 열게되면, html 코드들이 Dom을 만들게 된다.
  그리고 만약 html 코드의 특정 한 부분이 변경되게 된다면 전체 DOM을 새롭게 만들게 되어 비효율적인 구조이다.
  **하지만, 리액트는 가상의 DOM을 만들어서 진짜 DOM과 비교하여 변경 사항이 있을 경우 전체를 새롭게 만드는게 아니라 변경된 부분만 진짜 DOM의 반영하는 방식으로 작업을 수행한다.**

12. 리액트에선 왜 seo가 안될까
    SPA(싱글페이지)에서 자바스크립트로 페이지 데이터를 작성하기 때문에 SEO 문제점이 발생한다. 이 문제를 해결하기 위해서는 서버렌더링을 사용하면 된다.

- 서버 렌더링이란?
  - 웹 사이트를 처음 열면 모든 작업이 서버에서 수행되고, 브라우저는 모든 정보(검색 엔진에서 색인을 생성하는 정적 페이지)가 있는 HTML을 가져온다. JS가 로드 된 후 웹은 '단일 페이지 앱'으로 바뀌어 작동한다.

13. 깃 사용해본적
14. 깃 브랜치에서 왜 feature로 나눴는지.
    master, develop, feature, release, hotfix 브랜치이며, 각각의 역할은 아래와 같습니다.

- master : Stable 한 코드의 Archive이며 master 브랜치로 배포하면 언제든지 stable 한 상태의 코드가 배포됨.
- develop : Deploy-ready 상태의 코드가 있는 브랜치로 release 브랜치와 새로운 feature 브랜치 생성의 base가 되는 브랜치임. develop 브랜치에 들어왔다는 것은 테스트가 완료되고 언제든 배포해도 된다는 의미임.
- feature : 작업 브랜치로 develop 브랜치를 기준으로 생성함.
- release : 배포가 나갈 때 생성하는 브랜치로 develop 브랜치를 기준으로 생성하며 배포 & 모니터링이 끝난 이후에 develop 브랜치와 master 브랜치로 merge함.
- hotfix : master 브랜치에 release 브랜치가 merge된 이후에 예상치 못한 버그나 문제가 발생했을 때 빠르게 수정하기 위한 브랜치임. master 브랜치를 기준으로 생성해서 고쳐야 할 기능만 고쳐서 배포한 후에 문제가 마무리되면 develop 브랜치와 master브랜치로 merge 함.

15. var, let, const의 차이점

- var
  - 변수의 재 선언이 허용된다.
- let 과 const
  - 변수의 재 선언이 허용되지않는다.
  * let은 변수에 재 할당이 가능하지만, const는 변수 재 할당이 불가능하다.

16. 어떤 프로젝트가 재밌었는지
17. 함수형 프로그래밍을 사용해본적 있는지
    **함수형 프로그래밍이란,** 순수함수와 보조 함수의 조합을 통해 로직내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.

- 함수형 프로그래밍 개념에서 순수함수란?
  - 순수함수는 같은 입력이 주어지면, 같은 출력을 반환해야하고, side effect(부작용) 이 없어야한다.
    결국, 함수형 프로그래밍은 순수함수를 통해 sideeffect를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법
- OOP(객체지향프로그래밍)와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가?
  - 객체지향은 객체 안에 상태를 저장하고, 이 상태를 이용해서 메소드를 추가하고 상태변화를 설정하고 조정하기 위해 다양한 기능을 사용한다. 이에 반해 함수형 프로그래밍은 상태를 제어하는것보다 상태를 저장하지 않고 없애는데 주력한다. 예를 들면, 객체 지향은 상태를 저장하는 필드와 그 필드들을 이용해 기능을 제공하는 메소드를 만들고 클래스를 만듭니다. 반면 함수형은 몇몇 자료구조(list, map,set)등을 이용해 최적화된 동작을 만들어낸다.

18. axios 사용했는지 ajax와 차이점?

### 면접 후기
